var documenterSearchIndex = {"docs":
[{"location":"decompositions/#Matrix-Decompositions-1","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"","category":"section"},{"location":"decompositions/#UDT-(QR)-factorization-1","page":"Matrix Decompositions","title":"UDT (QR) factorization","text":"","category":"section"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"Based on the QR decomposition, we introduce a UDT factorization, where U is unitary, D is real-valued and diagonal, and T is upper-triangular. To decompose a given matrix M the udt function is exported.","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"julia> M = rand(10,10);\n\njulia> udt(M)\nUDT{Float64,Float64,Array{Float64,2}}([-0.246588 0.12668 â€¦ 0.582208 0.206435; -0.373953 -0.300804 â€¦ 0.152994 0.0523203; â€¦ ; -0.214686 -0.403362 â€¦ -0.124248 -0.390502; -0.40412 -0.147009 â€¦ 0.1839 0.197964], [2.15087, 1.47129, 1.14085, 0.911765, 0.850504, 0.620149, 0.545588, 0.412213, 0.305983, 0.148787], [-0.597235 -1.0 â€¦ -0.678767 -0.59054; -0.385741 0.0 â€¦ -1.0 -0.361263; â€¦ ; 0.0 0.0 â€¦ 0.0 0.0; 0.0 0.0 â€¦ 0.0 0.0])","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"In our tests (see paper/), this decomposition turns out to be superior to SVD for DQMC.","category":"page"},{"location":"decompositions/#SVD-factorization-1","page":"Matrix Decompositions","title":"SVD factorization","text":"","category":"section"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"The package provides convenient access to several LAPACK algorithms for calculating singular value decompositions (SVDs):","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"gesdd, gesdd!: Divide and conquer\ngesvd, gesvd!: Regular\ngesvj, gesvj!: Jacobi (based on JacobiSVD.jl)","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"Furthermore, you can access a type-generic, pure Julia implementation,","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"genericsvd, genericsvd! (based on GenericSVD.jl)","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"However, to keep the dependencies of the package minimal, only the first two are available by default and loading of the Jacobi or type-generic SVD is opt-in. We provide convenience functions StableDQMC.addJacobiSVD() and StableDQMC.addGenericSVD() to facilitate this process. See below for a quick demonstration.","category":"page"},{"location":"decompositions/#Automagically-opt-in-to-JacobiSVD/GenericSVD-1","page":"Matrix Decompositions","title":"Automagically opt-in to JacobiSVD/GenericSVD","text":"","category":"section"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"julia> using StableDQMC\n\njulia> gesvj\nERROR: UndefVarError: gesvj not defined\n\njulia> StableDQMC.addJacobiSVD()\n  Updating registry at C:\\Users\\carsten\\.julia\\registries\\General\n  Updating git-repo https://github.com/JuliaRegistries/General.git\n  Updating git-repo https://github.com/RalphAS/JacobiSVD.jl\n Resolving package versions...\n  Updating C:\\Users\\carsten\\Desktop\\stabledqmctest\\Project.toml\n  [2ca068c6] + JacobiSVD v0.0.0 #master (https://github.com/RalphAS/JacobiSVD.jl)\n  Updating C:\\Users\\carsten\\Desktop\\stabledqmctest\\Manifest.toml\n  [2ca068c6] + JacobiSVD v0.0.0 #master (https://github.com/RalphAS/JacobiSVD.jl)\nâ”Œ Warning: Package StableDQMC does not have JacobiSVD in its dependencies:\nâ”‚ - If you have StableDQMC checked out for development and have\nâ”‚   added JacobiSVD as a dependency but haven't updated your primary\nâ”‚   environment's manifest file, try Pkg.resolve().\nâ”‚ - Otherwise you may need to report an issue with StableDQMC\nâ”” Loading JacobiSVD into StableDQMC from project dependency, future warnings for StableDQMC are suppressed.\n[ Info: Recompiling stale cache file C:\\Users\\carsten.julia\\compiled\\v1.1\\JacobiSVD\\Frhox.ji for JacobiSVD [2ca068c6-2156-5cf0-8317-c67edf277a2c]\n\njulia> gesvj # gesvj and gesvj! are available now\ngesvj (generic function with 1 method)\n","category":"page"},{"location":"decompositions/#Manual-opt-in-1","page":"Matrix Decompositions","title":"Manual opt-in","text":"","category":"section"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"Provided that you have JacobiSVD.jl (or GenericSVD.jl) installed, you can get the LAPACK access functions gesvj, gesvj! (or genericsvd, genericsvd!) simply by import JacobiSVD (import GenericSVD).","category":"page"},{"location":"decompositions/#","page":"Matrix Decompositions","title":"Matrix Decompositions","text":"julia> using StableDQMC\n\njulia> gesvj\nERROR: UndefVarError: gesvj not defined\n\njulia> import JacobiSVD # using might lead to name conflicts\n\njulia> gesvj # gesvj and gesvj! are available now\ngesvj (generic function with 1 method)","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a library of numerically stable linear algebra routines for performing inversions as they appear in the calculation of Green's functions in determinant Quantum Monte Carlo.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For more details, check out the (unfinished!) accompanyig notes, in which we describe and benchmark a few specific algorithms. The plots in the notes have been generated with the notebooks in the notebook directory of this repository.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Feel free to give feedback, open issues, or contribute useful algorithms yourself! ðŸ™‚","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"] add StableDQMC","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package has only one dependency, Requires.jl.","category":"page"},{"location":"#Why-should-I-care?-1","page":"Home","title":"Why should I care?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"<table>\n  <tr>\n    <td><img src=\"https://github.com/crstnbr/StableDQMC.jl/raw/master/paper/figures/naive_vs_stable.png\" width=500px></td>\n    <td><img src=\"https://github.com/crstnbr/StableDQMC.jl/raw/master/paper/figures/decomp_comparison_simple.png\" width=500px></td>\n  </tr>\n</table>","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Left: Slice matrix product. Right: Equal-times Green's function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that \"SVD (D&C)\" is the algorithm used by Julia's svd function.","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> using LinearAlgebra, StableDQMC\n\njulia> B = rand(ComplexF64, 100,100);\n\njulia> Bfact = udt(B);\n\njulia> G = inv_one_plus_loh(Bfact);","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since the matrix B is well-conditioned in this case, we have","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> G â‰ˆ inv(I + B)\ntrue","category":"page"},{"location":"inversions/#Stable-Inversions-1","page":"Stable Inversion","title":"Stable Inversions","text":"","category":"section"},{"location":"inversions/#","page":"Stable Inversion","title":"Stable Inversion","text":"In DQMC, we commonly perform inversions like G = [1 + B]^-1 to obtain the equal-times Green's function and G = [A + B]^-1 for the time-displaced pendant. The following methods are exported to facilitate these tasks.","category":"page"},{"location":"inversions/#","page":"Stable Inversion","title":"Stable Inversion","text":"inv_one_plus, inv_one_plus!\ninv_sum, inv_sum!","category":"page"},{"location":"inversions/#","page":"Stable Inversion","title":"Stable Inversion","text":"When function names are suffixed with _loh, i.e. inv_one_plus_loh, a more sophisticated method is used for numerical stabilization (see the paper linked above for more details).","category":"page"}]
}
